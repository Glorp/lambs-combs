

    Impractical Lambda Calculus


Emacs Lisp-evaluating (start-lamb <x>) should start the thing.
(pictures generated by the Racket-thing will go in a dir called <x>.)
put cursor on end of next line, do C-x C-e, and wait for it to go beep boop:
(start-lamb "flat19")

then, for instructions, cursor on the line below and do <C-return>:
:slide halp

okay

:slide hello

:slide lamb-syntax

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

exp u ::= x         variable
          λx.u      abstraction
          u1 u2     application

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide lamb-computation

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

(λx.u1) u2
[u2/x]u1

e.g.
(λx.x) foo
foo

(λa.λb.λc.a c c) foo bar quux
(λb.λc.foo c c) bar quux
(λc.foo c c) quux
(foo quux) quux

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide lambda-churchnums

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

nums like:
l0 ≜ λf.λx.x
l0 is defined :)
l1 ≜ λf.λx.f x
l1 is defined :)
l2 ≜ λf.λx.f (f x)
l2 is defined :)
l3 ≜ λf.λx.f (f (f x))
l3 is defined :)
l4 ≜ λf.λx.f (f (f (f x)))
l4 is defined :)
l5 ≜ λf.λx.f (f (f (f (f x))))
l5 is defined :)

(λn.λf.λx.f (n f x)) l2
(λn.λf.λx.f (n f x)) (λf.λx.f (f x))
λf.λx.f ((λf.λx.f (f x)) f x)
λf.λx.f ((λx.f (f x)) x)
λf.λx.f (f (f x))


and like functions like successor
lsuc ≜ λn.λf.λx.f (n f x)
and plus
l+ ≜ λa.λb.λf.λx.a f (b f x)
l+ is defined :)
and stuff

l+ l2 l3
(λa.λb.λf.λx.a f (b f x)) (λf.λx.f (f x)) (λf.λx.f (f (f x)))
(λb.λf.λx.(λf.λx.f (f x)) f (b f x)) (λf.λx.f (f (f x)))
λf.λx.(λf.λx.f (f x)) f ((λf.λx.f (f (f x))) f x)
λf.λx.(λx.f (f x)) ((λf.λx.f (f (f x))) f x)
λf.λx.f (f ((λf.λx.f (f (f x))) f x))
λf.λx.f (f ((λx.f (f (f x))) x))
λf.λx.f (f (f (f (f x))))


 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide schon

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

  It is in the spirit of the axiomatic method as it has now
  received recognition, chiefly through the work of Hilbert,
  that we not only strive to keep the axioms as few and
  their content as limited as possible but also attempt to
  make the number of fundamental undefined notions as small
  as we can; we do this by seeking out those notions from
  which we shall best be able to construct all other notions
  of the branch of science in question.

  On the building blocks of mathematical logic
  Moses Schönfinkel

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide combs

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

for like our purposes:
a combinator is a function with no free variables

e.g.
λx.x
λa.λb.a
λf.λx.f (f x)

but not e.g.
λx.f x

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide comb-rules

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

but also syntax:
I x ≜ x
I is defined :)
BLAH x y z ≜ z y x
BLAH is defined :)
BLAH is defined :)

and then e.g.

I foo

BLAH foo bar quux
quux bar foo


BLAH foo bar ooo
ooo bar foo

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide ski

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

S x y z ≜ (x z) (y z)
S is defined :)
(or S ≜ λx.λy.λz.(x z) (y z))

K x y ≜ x
K is defined :)
(or K ≜ λx.λy.x)

I x ≜ x
I is defined :)
(or I ≜ λx.x)

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide iks

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

I x ≜ x
I is the identity function

K x y ≜ x
we can use K to make constant functions
e.g. (K 1) is the function that always returns 1

S x y z ≜ (x z) (y z)
S is like, oof, stuff...

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide try-to-ski

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

we can try to turn som lambdas into SKI

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide maybe-doable

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

(λx.x) foo
(I) foo
foo


(λf.λx.x) a b
(λx.x) b
b
(K I) a b
I b
b


(λa.λb.λc.c) q w e
(λb.λc.c) w e
(λc.c) e
e
(K (K I)) q w e
K I w e
I e
e

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide maybe-harder

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

(K (λb.K b)) q w e
(λb.K b) w e
K w e
w

(λf.λx.f x) a b
I a b
a b


(λf.λx.x f) a b
(λf.λx.x f) a b

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide tried-to-ski

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

translate by gradually rewriting and testing with dummy args

"abstraction elimination"

replace a lambda abstraction with a combinator that's been
given all but one of its arguments

I and K not so bad
λy.y                    => I
λx.u, if no free x in u => K u

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide s

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

S x y z ≜ (x z) (y z)

in translating we pass inn two arguments (all but one)
so the z will kind of replace the original lambda-parameter

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide lamb-syntax

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

exp u ::= x         variable
          λx.u      abstraction
          u1 u2     application

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:draw λf.λx.f x
(insert-pic "flat19/img3.png")
 


:slide s-fun

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

S x y z ≜ (x z) (y z)

function applications consists of two things
function-part-thing and argument-part-thing

the z will then be passed into both so _those_ need to be
made into functions accepting the original lambda parameter

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide maybe-harder

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

λa.λb.λc.b
λf.λx.f x
λf.λx.x f

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

(λa.λb.λc.b) q w e
(K (S (K K) I)) q w e
S (K K) I w e
K K w (I w) e
K (I w) e
I w
w


λf.λx.f x

(λf.λx.x f) a b
(λx.x a) b
b a
(S (K (S I)) (S (K K) I)) a b
K (S I) a (S (K K) I a) b
S I (S (K K) I a) b
I b (S (K K) I a b)
b (S (K K) I a b)
b (K K a (I a) b)
b (K (I a) b)
b (I a)
b a

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 




λf.λx.f x
λf.λx.x f

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide aid-understanding

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

"To sum up, Point-Free helps you tidy your code into more
concise implementations which tend to aid you in
understanding what it is you are trying to do."

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide ski-rules

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

λx.x                    => I
λx.u, if no free x in u => K u
λx.u1 u2                => S (λx.u1) (λx.u2)

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide eta

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

λx.f x is the same as f as long as there is no free x in x

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide maybe-harder

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

λa.λb.λc.b
λf.λx.f x

(λf.λx.x f) a b
(S (K (S I)) K) a b

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide ski-eta-rules

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

λx.x                      => I
λx.u, if no free x in u   => K u
λx.u x, if no free x in u => u
λx.u1 u2                  => S (λx.u1) (λx.u2)

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide many-ks

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

while translating we often get stuff like
λf.λx.K (f x)
which we then turn into
λf.S (K K) f

and the K K bit seems maybe silly
like there was nothing really important going on in there?

would be nice if we could just like _not_ throw additional
Ks onto uninteresting stuff

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide bc

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

B x y z ≜ x (y z)
B is defined :)
C x y z ≜ (x z) y
C is defined :)

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide maybe-harder

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

λa.λb.λc.b
λf.λx.f x

(λf.λx.x f) a b
(λx.x a) b
b a
(C I) a b
I b a
b a

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide skibc-rules

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

λx.x                         => I
λx.u, if no free x in u      => K u
λx.u x, if no free x in u    => u
λx.u1 u2,
          if no free x in u1 => B u1 (λx.u2)
          if no free x in u2 => C (λx.u1) u2
          else               => S (λx.u1) (λx.u2)

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide aid-understanding

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

"To sum up, Point-Free helps you tidy your code into more
concise implementations which tend to aid you in
understanding what it is you are trying to do."

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide fewer

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

we could do like S K K instead of I

S K K x
K x (K x)
x

there's some stuff about having maybe just one combinator
which you can kind of do. but we don't

says Schönfinkel:
"But on account of its obvious arbitrariness it is
probably without any real significance."

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide hask

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

foo x y = (x + y) / 2

:combify λx.λy./ (+ x y) 2
C (B C (B (B /) +)) 2

(flip ((.) flip ((.) ((.) (/)) (+))) 2) a b

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 


:slide aid-understanding

:slide link?

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

code: https://github.com/Glorp/lambs-combs

 =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^= 

